// upstream builds (fun takeaway)
= Asciidoctor: New, Noteworthy, & Beyond

== Brand

The oldest issue in the Asciidoctor repository is the issue to create a logo.
It's basically as old as the project.
After lots of discussion and many ideas and directions, we finally arrived at an idea that made sense.
The A is for Asciidoctor and AsciiDoc.
The equals is the first character that appears in most AsciiDoc documents, marking the doctitle.
It makes sense, then, that the logo looks like the title like of a document about Asciidoctor.
We choose the color carmine because it's bold and dynamic, exactly how we see this project.
And with that, I'm closing the issue.
Further discussion about the brand will happen in the newly minted brand repository.

== A Brief History

It's been awhile since I've given an update on Asciidoctor, so there's a ton to cover.
I'm going to briefly touch on the history of Asciidoctor because it provides important context for the beyond part.
I'm then going to talk a bit about Asciidoctor's growth and adoption, and the spread of the ecosystem.
I'll cover a few key features you may have missed in the last few releases.
Then I'll talk about where we're headed in the immediate future and further out.

Asciidoctor has a humble beginning.
I was working on a static site and needed a markup language that was developer-friendly, yet still comprehensive.
After passing it over the first time, I discovered AsciiDoc.
It fit like a glove.
But I needed a Ruby implementation to work with the static site generator, but there wasn't one.
A few months later, I got word from a friend at GitHub that they were working one.
Their intention was to replace AsciiDoc.py on GitHub because it was too slow and insecure.
The challenge, if choose to accept it, was develop enough of the parser so it would run on GitHub before they pulled the plug on AsciiDoc.py.
We just needed the hit the major stuff, paragraphs, section titles, lists.
After a string of sleepless nights, I managed to pull it off.
By January 2013, Asciidoctor was running on GitHub.com, available to 5 million+ repos.
Shortly thereafter, I become the project lead.

That should help you understand why Asciidoctor is in Ruby.
GitHub required it.
And I needed it to integrate AsciiDoc into the site generator I was using.

But where this story really becomes relevant to you is when Jason Porter, Andres Almiray, and Alex Soto, all started simultaneously working on various solutions to integrate Asciidoctor into the JVM via JRuby.
Jason and Andres were working on the Maven and Gradle plugins, respectively.
Those plugins remain vital to the story today, it was Alex Soto's work that really made that integration generally available.
Alex developed a pure Java API that wrapped and managed JRuby underneath so that you can use Asciidoctor on the JVM, hiding all the details of JRuby, which came be known as AsciidoctorJ.
Robert Panzer then came along and really took AsciidoctorJ to the next level, grokking the JRuby integration so that objects could move back and forth between the Java and Ruby runtimes seamlessly.
That really opened the door to being able to write full extensions purely in Java or Groovy, including a Groovy DSL that resembles the native one in Ruby.

At the same time there's this whole other initiative going on to bring Asciidoctor to JavaScript, which includes targetting Node, the browser, Electron, and even Nashorn.
That project is known as Asciidoctor.js and is led by Guillaume Grossetie.
It takes a different approach than AsciidoctorJ in that it actually transpiles the Ruby to JavaScript using a tool called Opal.
Asciidoctor.js plays an important role later in this story.

So you can use Asciidoctor from Ruby, JavaScript, Java, and of course, any language that runs on the JVM.
And many people do use all of those.
Since documentation, and in general writing, is not tied to any one plaform, it's important that a documentation text processor be able to run in a lot of places.
The native Ruby version, which we call "core", runs on GitHub and is used in many static site generators, Asciidoctor.js powers browser previews, tooling and editors, and more static site generators, AsciidoctorJ is used by the Maven, Gradle, and JavaDoc plugins and for tooling in IntelliJ.
These different uses also help to uncover issues and ultimately harden core.

Now that you know some of the history, I want to talk about the growth of Asciidoctor and its adoption.

== Growth
// see http://bestgems.org/gems/asciidoctor

Asciidoctor has grown beyond anything I could have imagined.

* 70 repositories
* 2.5M gem downloads
* 376 contributors
* 80 backers

As the leading implementation of AsciiDoc, Asciidoctor is also the official home of the AsciiDoc language definition.
We continue to refine the language to give you as much capability in as few characters as possible.

There are so many integrations, it's hard to keep up.
Some of the more notable ones are the Maven plugin, the Gradle plugin, the Jekyll plugin, the Middleman extension, the Reveal.js converter, the Atom plugin, the IntelliJ plugin, the Chrome/Firefox extension, and a Docker container.
I'll mention many other projects throughout this presentation.

== Adoption

Adoption is growing like crazy.
Year after year, Asciidoctor picks up notable users, and this year is no different.
The major adoption news this year came in August when Fedora announced it was switching from DocBook to Asciidoctor.
This migration was 4 years in the making, an effort which was sparked by a talk I gave about Asciidoctor at the Fedora User and Developer conference.
It's safe to say that Red Hat has embraced Asciidoctor across the board.
There are also personal reasons why this one matters to me.

Perhaps pertinent to more folks in this audience, Oracle and the Java EE leadership announced recently that the Java EE tutorial will be rewritten in AsciiDoc and processed by Asciidoctor.
(ref: https://javaee.github.io/tutorial/)
You'll also find Asciidoctor in use in the Spring projects, both for the documentation and, in the case of Spring REST Docs, as generated output for documenting REST APIs.

In terms of adoption by other businesses, Vogella does all its tutorials and trainings in Asciidoctor and the Khronos Group uses Asciidoctor for its Vulkan manual.
I mention both of those specifically because those companies also provide funding for the project.
If you want to talk to an author who's used Asciidoctor firsthand, find Matt Raible.
He wrote the JHipster MiniBook in AsciiDoc and converted it to PDF for download and print using Asciidoctor PDF.

I'm proud to say there are too many users of Asciidoctor to mention here, notable or not.
But you can find a list online of the ones we know about.
While there's still no page on the asciidoctor.org site that lists notable users of Asciidoctor, we keep track of the list in an open issue titled "`Who's Using Asciidoctor?`".
Our plan is to implement that page soon, which ties into something I'll mention later in the talk.

== Performance

If you've heard me talk about Asciidoctor before, you know I'm proud, and perhaps a bit obsessed, about its performance.
Yes, I recognize Ruby is not the fastest language out there (by a long shot).
But that kind of makes it a more exciting challenge.
Asciidoctor is written in Ruby and, short of rewriting it, my goal is to make it as fast as possible.

I've used all kinds of tricks to squeeze performance out of Ruby, which would generally apply to any programming language.
The main trick is to only run a regular expression or other expensive matcher if it's even possible that a match will occur.
In other words, be cheap.
Don't do work you don't have to do.
I call it berserker mode.

The Asciidoctor 1.5.6 release brought with it a 25% increase in speed over the previous release, nearly a 30% increase over 1.5.0.
That's thanks in part to improvements in Ruby itself.
As of now, Asciidoctor is 100x as fast as AsciiDoc.py.

So why all this focus on performance (aside from my personal challenge)?
The reality is, Asciidoctor is going to be asked to process a ton of documents, and nobody wants to wait a long time for that to happen.
We worked with a client recently who was converting more than 5,000 documents in a single build.
So these numbers start to add up quickly.
If you had to process 2 million documents, it would take AsciiDoc.py a year while it would only take Asciidoctor 3.5 days.
In more human-scale, the faster Asciidoctor runs, the quicker you get to see a preview of your document.
And that brings us to another point.

Most of the tooling for Asciidoctor is powered by Asciidoctor.js, which will get to in a minute.
Asciidoctor.js is generated JavaScript, which incurs a bit of a cost.
The faster core is, the faster that generated JavaScript is, and the faster you see a preview of the document in Atom, Chrome, or Firefox.

I still have some tricks up my sleeve for how to make the performance better, but it's going to get less of a priority now that we've achieved the level of performance we have now.
We may focus those optimizations on making Asciidoctor.js faster, for example.
And one day an implementation of Asciidoctor in a faster language might be in the cards.
Time will tell.

// should this be AsciidoctorJ / Asciidoctor.js?
== Integration

* Asciidoctor.js
 ** led by Guillaume Grosstie
 ** on par with Asciidoctor
 ** can write extensions in JavaScript
 ** full Unicode support
 ** new porcelain API (core & extension) (abstracts away Opal)
 ** support for major JavaScript environemnts (Node, browser, electron, Nashorn)
 ** support for templates, thus bringing reveal.js converter to JavaScript
 ** documentation

* AsciidoctorJ
 ** led by Robert Panzer
 ** 1.6.0 in progress
 ** overhauled extension API
 ** better integration between Ruby and Java objects
 ** more complete API, such as accessing / creating lists and tables
 ** support for Java 9 is coming; we're waiting on Java 9 support in JRuby, which is happening
 ** documentation

Improvements to Asciidoctor.js and Asciidoctor API are shaping the API in core, starting to make it stronger.

== Goodies

* icon:slide[code example] xrefstyle / proper ref catalog
 ** reference signifier terminology
* icon:slide[code example] advanced include tag filtering
* icon:slide[language flags] translations of all built-in attributes in 28 languages available from the repository
* a plethora of compliance fixes brought about by heavy usage of Asciidoctor; we are reaching into deep and dark corners at this point; with millions of pages of documentation, all bugs are shallow; every corner of the parser gets exercised
* much better SVG support, including support for interactive (object) and inline SVGs
* speaking of SVGs, tons of new diagramming tools are supported by Asciidoctor Diagram; if you are creating diagrams, it's definitely work a look
* Bespoke converter, which created this presentation
* Reveal.js converter, which is closely resembles the Bespoke converter; the two influence each other

== Antora

What I'm most excited to cover in this talk, and the most noteworthy, and most likely to impact the future of Asciidoctor, is a new project I've been working on named Antora.
The last couple of years, my company has been consulting with other companies on their documentation systems.
What we've noticed is that although there are a ton of static site generators available, few if any are well-suited for documentation sites...and more specifically AsciiDoc-based documentation sites.
//I talk a lot about that in my other talk, Applying Engineering Practices to Documentation
Antora is designed exactly for that use case.

Antora is an open source, modular Asciidoctor documentation toolchain and workflow that empowers technical writing teams to create, manage, collaborate on, remix, and publish documentation sites sourced from a variety of versioned content repositories without needing expertise in web technologies, build automation, or system administration.

Let's break that down:

* open source - MPL, hosted on GitLab
* modular - each part of Antora is its own package, which means you can modify it to suit your needs; even the UI is a separate component
* versioned content repositories - unlike most static site generators, Antora does not assume that the content is all in one place; instead, it goes out and clones content repositories and plucks files from branches of those repositories
* Asciidocotor - it then integrates deeply with Asciidoctor to generate the pages and the navigation
* without needing expertise - although what Antora does is complex, it's all driven by a simple configuration file called a playbook; this file describes at a high level what needs to be done; where's the source, where's the output, what settings should be used

Our goal is to make documentation sites easy to create, simple to manage, and fun to work on.
And it provides a real world use case for us to improve Asciidoctor.

Antora is built on Node and uses Asciidoctor.js, so it's going to have a particularly strong impact on Asciidoctor.js.
I meant it when I said that Asciidoctor.js was ready for prime time.

You can learn more about Antora and follow along with development at https://gitlab.com/antora.
I'm also working on a series of posts that introduce the project and explain the problem we're trying to solve with it.
You'll be hearing a lot about it in the coming months.

== Docs Overhaul

The Asciidoctor user manual has received considerable contributions in recent years, especially from Rocky Allen and Andrew Carver.
It remains the best place to get accurate and up-to-date information about the AsciiDoc syntax and Asciidoctor capabilities.

Indeed, it's great raw material, but it needs to be overhauled.
That's where Antora comes in.
We're going to drink our own beer by using Antora to build the next version of asciidoctor.org.
Not only will this bring some spring cleaning to the content that is already there, it will also address a long-standing problem we've had.
Right now, asciidoctor.org is really only about the core processor.
There are a few pages here and there about other projects in the ecosystem, but they are mostly isolated and one-pagers.
By using Antora, we can shift the documentation for the projects back to the project repositories and then consume them when the site is built.
It's really the exact case for which Antora was designed, so it's a chance to see it in action.

Anyone interested in helping with the writing, please reach out to us.
Many hands make light work.
We'd also welcome the input of a designer to help improve the UI for Antora that we use for the site.

TODO concluding statement / transition?

== Semantic HTML

(slide: html5 logo?)
From the very first day I worked on the HTML output in Asciidoctor I knew there would come a time when we needed to rework the converter to produce semantic HTML.
At the time, I decided to mimic the output of Asciidoc.py, as eccentric as it was, because the goal at that time was to be a drop in replacement and gain adoption.
We'll, that's behind us, so it's time to reevaluate.

(slide: html5s converter)
Jakub has started work on a semantic HTML5 converter using custom templates.
I think this is a great way to experiment with the HTML structure so we can get it right.
The EPUB3 and Bespoke converters also propose a lot of ideas for how to better structure the HTML.

Eventually, we want to pull this work into core and replace the existing converter.
Technically, it's not hard to do.
It's just generating different tags than the ones we generate today.
The hard part is deciding on what those tags should be.
We definitely need your input on this.
If you've ever complained about the HTML that Asciidoctor generates, you have a vested interest in giving feedback now so we can get to something that you (as a collective) will like.
We'll also need a new default stylesheet, which is a good time to revisit the aging build process we use to make it now.

== Validation

I had always planned on adding validation of AsciiDoc to the processor.
As I started to think about how to do it, I realized that it doesn't make sense to do it that way.
The needs of the processor are very different from the needs of a validator.
For example, a processor doesn't really need to keep track of where it took things from.
It only cares about the resolved value and some general information about context for reporting.
A validator, on the other hand, is very concerned about where every character is so that it can give exact character offsets and perhaps even fix the problem itself.
A validator also has a very specific way of collecting and reporting problems.
So we can kind of think of the processor as following the happy path whereas the validator wants to stop and examine every detour and oddity.

That brings us to textlint.
(slide: textlint banner)
I did some searching for a validation framework I could build on.
eslint is a very popular tool for validating JavaScript code.
textlint is inspired by eslint.
First, you implement a parser for the language, which I've started to do.
It currently only parses blocks, but I'm going to take a crack at parsing inline nodes as well like formatted text and macros.
(slide: github project for textlint-plugin-asciidoc)
Once the document is parsed, then you write rules that listen for nodes and look for things to validate.
For example, if you wanted to check for insecure URLs, you could listen for all paragraph nodes and only check for URLs in those regions, thus skipping any verbatim blocks.
(slide: insecure url rule example)
And you get exact line number and character offsets in the message.

With this system, you have much more control over what is validated.
We'll likely provide a core set of rules, but you can write your own.

We still have a ways to go on the validator, but the good news is that the effort is now underway.

== Grammar

When talking about validation, I mentioned inline parsing.
This is probably the Achilles heal of Asciidoctor.
(slide: parser icon => inline AST tree)
When I first implemented Asciidoctor, I was aiming for compatibility with AsciiDoc.py.
Therefore, I took the same approach of using regular expressions to parse inline nodes.
Since AsciiDoc is only a semi-structured language, this works amazingly well.
But we have reached the limits of that strategy.
It's time (perhaps past time) to switch to an inline parser.
It will likely be a recursive decent parser with some overrides since that's what's used in most Markdown implementations.
I'll probably implement it first in the validator, which provides a safe place to work on it.
Once that's worked out, I'll then bring it in to core.
There may be some migration, but I expect that in most cases, it's only going to get more scenarios right, not less.

== Releases

This is a short section.
Our experience in the past few years, especially as the Asciidoctor ecosystem grows, has it painfully obvious that we need to shift to semantic versioning.
Each micro release of Asciidoctor core is like a major release, so there's no room for anything else.
We need to make room.
We also need to move away from a single version scheme across the ecosystem.
I thought it was the right way to go, but I was mistaken.
It's only slowed things down.
We'll be much better off if projects themselves are versioned semantically and we then track compatible versions.

Once we shift to 1.6.0, releases will go 1.6.0, 1.7.0, then perhaps 2.0.0 if a major change is ready to go in.

We may still align the minor version number for the core components, AsciidoctorJ and Asciidoctor.js.
But the alignment wouldn't extend much outside of those projects.

A shift to semantic versioning should also allow us to release faster.
I know I've held up the release because minor stuff got stuck behind major stuff.
I'm not ready to commit to timed releases yet, but I am thinking about them.

== Funding

Speaking of time, I need time to work on Asciidoctor.
And time means money.
While I mentioned Asciidoctor has received support from 80 backers, only few of those are steady contributions.
If we're going to take on the challenges we have set before us, we're going to need funding, which converts to time and resources.
The more time I can spend on Asciidoctor, the faster we can move.
My effort is multiplied by the effort of the community, but that only happens when I'm actively driving the ship.

== Wrapup

TODO
